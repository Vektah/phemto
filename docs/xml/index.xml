<?xml version="1.0"?>
<page title="Five minute guide to Phemto" here="Phemto guide">
    <long_title>Dependency injection for PHP : The five minute guide to Phemto</long_title>
    <context>
        <section name="what_is_phemto" title="The five minute guide to Dependency Injection">
            <p>
                In jargon speak, <em>Phemto</em> is a lightweight, highly automated,
                dependency injection container.
                In simpler terms, <em>Phemto</em>'s job is to instantiate objects from as
                little information as possible; dramatically reducing coupling within
                an application or framework.
            </p>
            <p>
                Why is this useful?
                The easiest way to understand is to think of &quot;Dependency Injection&quot;
                is as part of a scale with hard coding at the other end.
            </p>
            <p>
                Creating objects in your application with hard code <code>new</code>
                statements is very explicit, but it makes things difficult to change later.
                Take this code...
<php><![CDATA[
class MyController {
    function __construct() {
        ...
        $connection = new MysqlConnection();
    }
}
]]></php>
                Here <code>MyController</code> has a dependency on <code>MysqlConnection</code>.
            </p>
            <p>
                The <code>new</code> operator is easy to understand, but <code>MyController</code>
                can only ever use a MySQL database.
                Recoding it to allow subclassing hardly helps, because that will expose other
                parts of the implementation that will tie you in.
                Anyway, multiple dependencies will defeat inheritance by causing a class explosion.
                You can only play the inheritance card once.
            </p>
            <p>
                The next step up is to use a factory...
<php><![CDATA[
class MyController {
    function __construct($connection_pool) {
        ...
        $connection = $connection_pool->getConnection();
    }
}
]]></php>
                This is a very effective solution.
                The factory can be set to a certain connection type, either explicitely
                or by using a configuration file.
                Factories often create whole families of objects, when they are known as
                <em>Abstract Factory</em> or <em>Repository</em>.
                There are limitations though.
            </p>
            <p>
                Factories can introduce a lot of extra code.
                If you want to unit test the classes with mock objects, you will need to
                mock not just the dependency, but the factory as well.
                That's quite a bit of test clutter.
            </p>
            <p>
                Even in live code, if you want to create an object the factory author
                has not thought of, then you have to subclass or rewrite the factory.
                For frameworks this is a big problem.
            </p>
            <p>
                Another way is to take construction out of the client objects altogether,
                doing the whole lot up front...
<php><![CDATA[
class MyController {
    function __construct($registry) {
        ...
        $connection = $registry->connection;
    }
}
...
$registry = new Registry();
$registry->connection = new MysqlConnection();
$controller = new MyController($registry);
]]></php>
                The <code>Registry</code> is pretty passive, and so the application now has
                to get involved in creating, or overriding, lot's of objects.
                You may also end up instantiating objects that don't get used.
                This pattern is not enough if you want to use lazy object creation, or
                <em>Singleton</em>s, or some other object lifecycle.
            </p>
            <p>
                Worse, if a dependency has other dependencies that need to be handled
                with the <em>Registry</em>, the setting up can get very tangled.
            </p>
            <p>
                We can make the <em>Registry</em> pattern more sophisticated it if we
                allow it to instantiate objects.
                It then becomes a <em>Service Locator</em>...
<php><![CDATA[
class MyController {
    function __construct($services) {
        ...
        $connection = $services->connection;
    }
}
...
$services = new ServiceLocator();
$services->connection('MysqlConnection');
$controller = new MyController($services);
]]></php>
                Now the wiring can be set in any order, but the <code>ServiceLocator</code>
                needs to know how to create the <code>MysqlConnection</code>.
                This can be handled by registering factories or with clever reflection tricks,
                although passing parameters can become fiddly.
                At least lifecycles are now under the control of the application programmer.
            </p>
            <p>
                Unfortunately this near panacea shares a problem with the <em>Registry</em>.
                Every class that uses an interface this way has to have the
                <code>ServiceLocator</code> as a dependency, which is intrusive.
                If you try to mix two systems with different <em>Service Locator</em>s, you
                are out of luck.
            </p>
            <p>
                <em>Dependency Injection</em> starts from a different track.
                Let's go back to our first example...
<php><![CDATA[
class MyController {
    function __construct() {
        ...
        $connection = new MysqlConnection();
    }
}
]]></php>
                ...and make the dependency external...
<php><![CDATA[
class MyController {
    function __construct(Connection $connection) {
        ...
    }
}
]]></php>
                At first sight this looks terrible, as now every top level script has to
                know the dependencies.
                Changing the database connection will now have to be done in hundreds of
                places.
                Well, that would be true if we had to use <code>new</code>...
<php><![CDATA[
$injector = new Phemto();
$controller = $injector->create('MyController');
]]></php>
                Now the controller specifies only an interface, and
                the job of instantiation has been handed to an intermediary.
                The <code>MyController</code> is no longer needs to know about the
                <code>MysqlConnection</code>.
                Instead the <code>$injector</code> has to know about both.
                This is &quot;Inversion of Control&quot;.
            </p>
            <p>
                Fortunately, <code>Phemto</code> is specialised in discovering how
                to create classes, and automates a surprising amount.
                Just from the interface hint, it can deduce the class that fits the bill.
            </p>
        </section>
        <section name="installing_phemto" title="Installing Phemto">
            <p>
                The phemto download is a pure PHP tarball.
                Simply untar it...
                <sh>tar -zxf phemto_0.1_alpha3.tar.gz</sh>
                You can then <code>require_once()</code> the <em>phemto.php</em> file
                directly, or place the phemto folder in your path.
            </p>
            <p>
                Phemto's only dependency is on the PHP reflection API.
            </p>
        </section>
        <section name="phemto_instantiation" title="Creating objects with Phemto">
            <p>
                The simplest way Phemto creates objects is straight from the class name...
<php><![CDATA[
class Porsche911 { }

$injector = new Phemto();
$car = $injector->create('Porsche911');
]]></php>
                It will search the classes currently registered by the system to
                find a match.
            </p>
            <p>
                If only one class could possibly match, then it will be instantiated
                straight away.
                In doing so, <em>Phemto</em> is smart enough to understand abstract
                classes and interfaces...
<php><![CDATA[
abstract class Car { }
class Porsche911 extends Car { }

$injector = new Phemto();
$car = $injector->create('Car');
]]></php>
                Here <code>$car</code> is an instance of <code>Porsche911</code>.
                Similarily...
<php><![CDATA[
interface Transport { }
class Porsche911 implements Transport { }

$injector = new Phemto();
$car = $injector->create('Transport');
]]></php>
                Again, the concrete <code>Porsche911</code> is created, as it's the
                only option.
            </p>
            <p>
                If there is ambiguity, then <em>Phemto</em> will throw an exception.
                The ambiguity can be resolved by giving Phemto additional wiring...
<php><![CDATA[
interface Transport { }
class Porsche911 implements Transport { }
class RouteMaster implements Transport { }

$injector = new Phemto();
$injector->willUse('Porsche911');
$car = $injector->create('Transport');
]]></php>
                This is handy if there is a default implementation that you now want
                to override, but the original is still in scope.
            </p>
            <p>
                <em>Phemto</em> has two methods to automatically instantiate parameters.
                The first is by type hints...
<php><![CDATA[
interface Engine { }

class Porsche911 {
    function __construct(Engine $engine) { }
}

class Flat6 implements Engine { }

$injector = new Phemto();
$car = $injector->create('Porsche911');
]]></php>
                This is equivalent to <code>new Porsche911(new Flat6())</code>.
                This technique is useful for framework authors, who only have to expose
                interface names.
            </p>
            <p>
                Notice that we have not had to change the client code, even though
                we've changed the constructor signature.
            </p>
            <p>
                The other way <em>Phemto</em> can fill parameters is by variable name...
<php><![CDATA[
class Porsche911 {
    function __construct($engine) { }
}

interface Engine { }
class Flat6 implements Engine { }

$injector = new Phemto();
$injector->forVariable('engine')->willUse('Engine');
$car = $injector->create('Porsche911');
]]></php>
                Again we instantiate <code>$car</code> to <code>new Porsche911(new Flat6())</code>.
                Here we've chosen the variable <code>$engine</code> to map to an interface.
                Phemto can apply it's automation rules from there.
            </p>
            <p>
                <em>Phemto</em> can call methods other than the constructor...
<php><![CDATA[
interface Seat { }
interface SportsCar { }

class Porsche911 implements SportsCar {
    function fitDriversSeat(Seat $seat) { }
}

class BucketSeat implements Seat { }

$injector = new Phemto();
$injector->forType('SportsCar')->call('fitDriversSeat');
$car = $injector->create('Porsche911');
]]></php>
                This code is the same as...
<php><![CDATA[
$car = new Porsche911();
$car->fitDriversSeat(new BucketSeat());
]]></php>

            </p>
            <p>
                You don't always want to create the same object.
                Sometimes the choice depends on context.
<php><![CDATA[
interface Seat { }

class Car {
    function __construct(Seat $seat) { }
}
class FordEscort extends Car;
class Porsche911 extends Car;

class StandardSeat implements Seat { }
class BucketSeat implements Seat { }

$injector = new Phemto();
$injector->willUse('StandardSeat');
$injector->whenCreating('Porsche911')->willUse('BucketSeat');
$car = $injector->create('Porsche911');
]]></php>
                This ensures that the default <code>$seat</code> is the
                <code>StandardSeat</code> class, but that the <code>Porsche911</code>
                will use the <code>BucketSeat</code>.
            </p>
        </section>
    </context>
</page>

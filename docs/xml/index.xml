<?xml version="1.0"?>
<page title="Five minute guide to Phemto" here="phemto">
    <long_title>Dependency injection for PHP : The five minute guide to Phemto</long_title>
    <content>
        <section name="what_is_phemto" title="The five minute guide to Dependency Injection">
            <p>
                In jargon speak, <em>Phemto</em> is a lightweight, highly automated,
                dependency injection container.
                In simpler terms, <em>Phemto</em>'s job is to instantiate objects from as
                little information as possible; dramatically reducing coupling within
                an application or framework.
            </p>
            <p>
                Why is this useful?
                The easiest way to understand is to think of &quot;Dependency Injection&quot;
                is as part of a scale with hard coding at the other end.
            </p>
            <p>
                Creating objects in your application with hard code <code>new</code>
                statements is very explicit, but it makes things difficult to change later.
                Take this code...
<php><![CDATA[
class MyController {
    function __construct() {
        ...
        $connection = new MysqlConnection();
    }
}
]]></php>
                Here <code>MyController</code> has a dependency on <code>MysqlConnection</code>.
            </p>
            <p>
                The <code>new</code> operator is easy to understand, but <code>MyController</code>
                can only ever use a MySQL database.
                Recoding it to allow subclassing hardly helps, because that will expose other
                parts of the implementation that will tie you in.
                Anyway, multiple dependencies will defeat inheritance by causing a class explosion.
                You can only play the inheritance card once.
            </p>
            <p>
                The next step up is to use a factory...
<php><![CDATA[
class MyController {
    function __construct($connection_pool) {
        ...
        $connection = $connection_pool->getConnection();
    }
}
]]></php>
                This is a very effective solution.
                The factory can be set to a certain connection type, either explicitely
                or by using a configuration file.
                Factories often create whole families of objects, when they are known as
                <em>Abstract Factory</em> or <em>Repository</em>.
                There are limitations though.
            </p>
            <p>
                Factories can introduce a lot of extra code.
                If you want to unit test the classes with mock objects, you will need to
                mock not just the dependency, but the factory as well.
                That's quite a bit of test clutter.
            </p>
            <p>
                Even in live code, if you want to create an object the factory author
                has not thought of, then you have to subclass or rewrite the factory.
                For frameworks this is a big problem.
            </p>
            <p>
                Another way is to take construction out of the client objects altogether,
                doing the whole lot up front...
<php><![CDATA[
class MyController {
    function __construct($registry) {
        ...
        $connection = $registry->connection;
    }
}
...
$registry = new Registry();
$registry->connection = new MysqlConnection();
$controller = new MyController($registry);
]]></php>
                The <code>Registry</code> is pretty passive, and so the application now has
                to get involved in creating, or overriding, lot's of objects.
                You may also end up instantiating objects that don't get used.
                This pattern is not enough if you want to use lazy object creation, or
                <em>Singleton</em>s, or some other object lifecycle.
            </p>
            <p>
                Worse, if a dependency has other dependencies that need to be handled
                with the <em>Registry</em>, the setting up can get very tangled.
            </p>
            <p>
                We can make the <em>Registry</em> pattern more sophisticated it if we
                allow it to instantiate objects.
                It then becomes a <em>Service Locator</em>...
<php><![CDATA[
class MyController {
    function __construct($services) {
        ...
        $connection = $services->connection;
    }
}
...
$services = new ServiceLocator();
$services->connection('MysqlConnection');
$controller = new MyController($services);
]]></php>
                Now the wiring can be set in any order, but the <code>ServiceLocator</code>
                needs to know how to create the <code>MysqlConnection</code>.
                This can be handled by registering factories or with clever reflection tricks,
                although passing parameters can become fiddly.
                At least lifecycles are now under the control of the application programmer.
            </p>
            <p>
                Unfortunately this near panacea shares a problem with the <em>Registry</em>.
                Every class that uses an interface this way has to have the
                <code>ServiceLocator</code> as a dependency, which is intrusive.
                If you try to mix two systems with different <em>Service Locator</em>s, you
                are out of luck.
            </p>
            <p>
                <em>Dependency Injection</em> starts from a different track.
                Let's go back to our first example...
<php><![CDATA[
class MyController {
    function __construct() {
        ...
        $connection = new MysqlConnection();
    }
}
]]></php>
                ...and make the dependency external...
<php><![CDATA[
class MyController {
    function __construct(Connection $connection) {
        ...
    }
}
]]></php>
                At first sight this looks terrible, as now every top level script has to
                know the dependencies.
                Changing the database connection will now have to be done in hundreds of
                places.
                Well, that would be true if we had to use <code>new</code>...
<php><![CDATA[
$injector = new Phemto();
$controller = $injector->create('MyController');
]]></php>
                Now the controller specifies only an interface, and
                the job of instantiation has been handed to an intermediary.
                The <code>MyController</code> is no longer needs to know about the
                <code>MysqlConnection</code>.
                Instead the <code>$injector</code> has to know about both.
                This is &quot;Inversion of Control&quot;.
            </p>
            <p>
                Fortunately, <code>Phemto</code> is specialised in discovering how
                to create classes, and automates a surprising amount.
                Just from the interface hint, it can deduce the class that fits the bill.
            </p>
        </section>
        <section name="installing_phemto" title="Installing Phemto">
            <p>
                The phemto download is a pure PHP tarball.
                Simply untar it...
                <sh>tar -zxf phemto_0.1_alpha3.tar.gz</sh>
                You can then <code>require_once()</code> the <em>phemto.php</em> file
                directly, or place the phemto folder in your path.
            </p>
            <p>
                Phemto's only dependency is on the PHP reflection API.
            </p>
        </section>
        <section name="using_phemto" title="Using Phemto">
            <p>
                The expected use case for Phemto is in the top level of an application
                or framework.
            </p>
            <p>
                Firstly you write your classes as normal...
<php><![CDATA[
class Permissions { ... }

class Authentication {
    function __construct($permissions) { ... }
}

class MyPage implements Page {
    function __construct($authentication) { ... }
}
]]></php>
                This is a simple <em>Page controller</em> architecture.
                We can unit test <code>Page</code> fairly easily, because it's
                <code>Authentication</code> dependency is passed in the constructor.
                We can use a mock version for testing, and just concentrate on the
                page logic.
            </p>
            <p>
                Next we create an application wiring file, let's call it
                &quot;wiring.php&quot;, that includes all the configuration for
                this application...
<php><![CDATA[
<?php
require_once('phemto/phemto.php');

$injector = new Phemto();
$injector->forVariable('authentication')->willUse('Authentication');
$injector->whenCreating('Authentication')
         ->forVariable('permissions')->willUse(new Sessionable('Permissions'));
return $injector;
?>
]]></php>
                Here we tell the dependency injector that whenever we see the variable
                <code>$authentication</code> we want to create an instance of
                <code>Authentication</code>.
                The <code>$permissions</code> object has a different lifecycle though.
                <code>Sessionable</code> says that if possible it will be read from the session,
                otherwise it will be created just once.
                More on the wiring syntax and lifecycles in the next section.
            </p>
            <p>
                Our top level scripts now swap their <code>new</code> statements
                for <em>Phemto</em> factory calls...
<php><![CDATA[
<?php
require_once('lib/my_page.php');

$injector = include('wiring.php');
$page = $injector->create('Page');
?>
<html>...</html>
]]></php>
                So isolated is our code from the top level scripts, that we can
                add and remove dependencies to the underlying classes without ever
                again having to alter our top level scripts.
            </p>
            <p>
                Framework authors have different concerns.
                As they probably already have a central point for creating pages, their
                main concern is with adapting to your components.
            </p>
            <p>
                Suppose we want write an <code>Authentication</code> implementation
                based on an interface supplied by the framework...
<php><![CDATA[
interface Authentication { ... }

class InternalFrontControllerActionChainThingy {
    function __construct(Authentication $authentication, ...) { ... }
}
]]></php>
                Our component wants to use the same database connection
                as the framework, but we also want to add a third party caching component.
<php><![CDATA[
require_once('cache.php');

class OurAuthentication implements Authentication {
    function __construct(Database $database, DatabaseCache $cache) { ... }
}
]]></php>
                For a factory based framework this is a bit of a nightmare, as the
                framework will not know how to create the caching component or where to
                put it.
                If the framework is using <em>Dependency Injection</em>, then this is just
                an amendment to the wiring.
            </p>
            <p>
                This wiring could be amended directly, with a user supplied wiring file...
<php><![CDATA[
$injector = include('framework/wiring.php');
$injector->willUse('OurAuthenticator');
return $injector;
]]></php>
                More likely the framework will wrap the DI tool within it's own registration
                system...
<php><![CDATA[
class FrameworkRegistration {
    ...
    function register($class, $dependencies = array()) {
        $this->injector->whenCreating('Controller')->willUse($class);
        foreach (dependencies as $dependency) {
            $this->injector->whenCreating('Controller')
                           ->whenCreating($class)
                           ->willUse($dependency);
        }
    }
}
]]></php>
            </p>
        </section>
        <section name="wiring" title="Wiring with Phemto">
            <p>
                The simplest way Phemto creates objects is straight from the class name...
<php><![CDATA[
class Porsche911 { }

$injector = new Phemto();
$car = $injector->create('Porsche911');
]]></php>
                It will search the classes currently registered by the system to
                find a match.
            </p>
            <p>
                If only one class could possibly match, then it will be instantiated
                straight away.
                In doing so, <em>Phemto</em> is smart enough to understand abstract
                classes and interfaces...
<php><![CDATA[
abstract class Car { }
class Porsche911 extends Car { }

$injector = new Phemto();
$car = $injector->create('Car');
]]></php>
                Here <code>$car</code> is an instance of <code>Porsche911</code>.
                Similarily...
<php><![CDATA[
interface Transport { }
class Porsche911 implements Transport { }

$injector = new Phemto();
$car = $injector->create('Transport');
]]></php>
                Again, the concrete <code>Porsche911</code> is created, as it's the
                only option.
            </p>
            <p>
                If there is ambiguity, then <em>Phemto</em> will throw an exception.
                The ambiguity can be resolved by giving Phemto additional wiring...
<php><![CDATA[
interface Transport { }
class Porsche911 implements Transport { }
class RouteMaster implements Transport { }

$injector = new Phemto();
$injector->willUse('Porsche911');
$car = $injector->create('Transport');
]]></php>
                This is handy if there is a default implementation that you now want
                to override, but the original is still in scope.
            </p>
            <p>
                <em>Phemto</em> has two methods to automatically instantiate parameters.
                The first is by type hints...
<php><![CDATA[
interface Engine { }

class Porsche911 {
    function __construct(Engine $engine) { }
}

class Flat6 implements Engine { }

$injector = new Phemto();
$car = $injector->create('Porsche911');
]]></php>
                This is equivalent to <code>new Porsche911(new Flat6())</code>.
                This technique is useful for framework authors, who only have to expose
                interface names.
            </p>
            <p>
                Notice that we have not had to change the client code, even though
                we've changed the constructor signature.
            </p>
            <p>
                The other way <em>Phemto</em> can fill parameters is by variable name...
<php><![CDATA[
class Porsche911 {
    function __construct($engine) { }
}

interface Engine { }
class Flat6 implements Engine { }

$injector = new Phemto();
$injector->forVariable('engine')->willUse('Engine');
$car = $injector->create('Porsche911');
]]></php>
                Again we instantiate <code>$car</code> to <code>new Porsche911(new Flat6())</code>.
                Here we've chosen the variable <code>$engine</code> to map to an interface.
                Phemto can apply it's automation rules from there.
            </p>
            <p>
                Sometimes instance specific parameters need to be passed.
                The simplest way to do this is just add them to the create method...
<php><![CDATA[
class Porsche911 {
    function __construct($fluffy_dice, $nodding_dog) { }
}

$injector = new Phemto();
$car = $injector->create('Porsche911', true, false);
]]></php>
                These parameters will fill unfulfilled slots in the constructors, here
                giving <code>new Porsche911(true, false)</code>.
            </p>
            <p>
                As unnamed parameters can be a bit error prone when things get complicated,
                there is a named parameter option as well...
<php><![CDATA[
class Porsche911 {
    function __construct($fluffy_dice, $nodding_dog) { }
}

$injector = new Phemto();
$car = $injector->fill('fluffy_dice', 'nodding_dog')
                ->with(true, false)
                ->create('Porsche911', true);
]]></php>
                These parameters apply to dependencies as well.
            </p>
            <p>
                <em>Phemto</em> can call methods other than the constructor...
<php><![CDATA[
interface Seat { }
interface SportsCar { }

class Porsche911 implements SportsCar {
    function fitDriversSeat(Seat $seat) { }
}

class BucketSeat implements Seat { }

$injector = new Phemto();
$injector->forType('SportsCar')->call('fitDriversSeat');
$car = $injector->create('Porsche911');
]]></php>
                This code is the same as...
<php><![CDATA[
$car = new Porsche911();
$car->fitDriversSeat(new BucketSeat());
]]></php>
                Calling non-constructor methods in this way is called setter injection.
            </p>
            <p>
                You don't always want to create the same object.
                Sometimes the choice depends on context...
<php><![CDATA[
interface Seat { }

class Car {
    function __construct(Seat $seat) { }
}
class FordEscort extends Car;
class Porsche911 extends Car;

class StandardSeat implements Seat { }
class BucketSeat implements Seat { }

$injector = new Phemto();
$injector->willUse('StandardSeat');
$injector->whenCreating('Porsche911')->willUse('BucketSeat');
$car = $injector->create('Porsche911');
]]></php>
                This ensures that the default <code>$seat</code> is the
                <code>StandardSeat</code> class, but that the <code>Porsche911</code>
                will use the <code>BucketSeat</code>.
            </p>
            <p>
                The <code>whenCreating()</code> method creates a whole new nested
                version of <em>Phemto</em> so that context can be applied to all
                of the preceding wiring methods. E.g...
<php><![CDATA[
class Car {
    function __construct($seat) { }
}
class FordEscort extends Car;
class Porsche911 extends Car;

class StandardSeat { }
class BucketSeat { }

$injector = new Phemto();
$injector->willUse('StandardSeat');
$injector->whenCreating('Porsche911')->forVariable('seat')->willUse('BucketSeat');
$car = $injector->create('Porsche911');
]]></php>
            </p>
        </section>
    </content>
    <internal>
        <link>
            <a href="#what_is_phemto">What is Phemto?</a>
        </link>
        <link>
            <a href="#installing_phemto">Installation</a> from the tarball.
        </link>
        <link>
            <a href="#using_phemto">Using Phemto</a> in your application.
        </link>
        <link>
            The <a href="#wiring">wiring syntax</a>.
        </link>
    </internal>
    <external>
        <link>
            Phemto project page on <a href="http://sourceforge.net/projects/phemto/">SourceForge</a>.
        </link>
        <link>
            Martin Fowler's <a href="http://martinfowler.com/articles/injection.html">description of DI</a>.
        </link>
    </external>
    <meta>
        <keywords>
            dependency injection,
            dependency injection pattern,
            dependency injection container,
            php dependency injection,
            php,
            di,
            object lifecycle,
            singleton pattern,
            registry pattern,
            service locator pattern,
            inversion of control,
            interfaces,
            mock object,
            mock objects,
            unit testing,
            framework
        </keywords>
    </meta>
</page>
